#!/usr/bin/env node
/**
 * Convert Z-Anatomy export metadata to Anatomy Explorer data format
 * 
 * This script takes the torso_metadata.json generated by the Blender export
 * and generates TypeScript data files compatible with the app.
 * 
 * Usage:
 *   node scripts/generate_data.js
 * 
 * Or with ts-node:
 *   npx ts-node scripts/generate_data.ts
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Paths
const METADATA_PATH = path.join(__dirname, '../public/models/torso_metadata.json');
const OUTPUT_PATH = path.join(__dirname, '../src/data/generatedTorsoData.ts');

// Color palette for structure types
const TYPE_COLORS = {
  bone: { default: '#E8DCC4', highlight: '#FFF8E7' },
  muscle: { default: '#C41E3A', highlight: '#FF4D6A' },
  tendon: { default: '#D4A574', highlight: '#E8C9A0' },
  ligament: { default: '#8B7355', highlight: '#A89070' },
  cartilage: { default: '#A8D5BA', highlight: '#C5E8D2' },
  fascia: { default: '#D4A5A5', highlight: '#E8C5C5' },
  organ: { default: '#8B4557', highlight: '#A85A6F' },
};

// Human-readable names for common anatomical terms
const NAME_MAPPINGS = {
  // Muscles
  rectus_abdominis: { common: 'Six-Pack Muscle', anatomical: 'Rectus abdominis' },
  external_oblique: { common: 'Side Abs (Outer)', anatomical: 'External oblique' },
  internal_oblique: { common: 'Side Abs (Inner)', anatomical: 'Internal oblique' },
  transversus_abdominis: { common: 'Deep Core Muscle', anatomical: 'Transversus abdominis' },
  pectoralis_major: { common: 'Chest Muscle', anatomical: 'Pectoralis major' },
  pectoralis_minor: { common: 'Small Chest Muscle', anatomical: 'Pectoralis minor' },
  serratus_anterior: { common: "Boxer's Muscle", anatomical: 'Serratus anterior' },
  latissimus_dorsi: { common: 'Lats', anatomical: 'Latissimus dorsi' },
  erector_spinae: { common: 'Back Extensors', anatomical: 'Erector spinae' },
  diaphragm: { common: 'Breathing Muscle', anatomical: 'Thoracic diaphragm' },
  intercostals: { common: 'Rib Muscles', anatomical: 'Intercostal muscles' },
  psoas_major: { common: 'Hip Flexor', anatomical: 'Psoas major' },
  iliacus: { common: 'Hip Muscle', anatomical: 'Iliacus' },
  quadratus_lumborum: { common: 'Lower Back Muscle', anatomical: 'Quadratus lumborum' },
  gluteus_maximus: { common: 'Glutes', anatomical: 'Gluteus maximus' },
  gluteus_medius: { common: 'Side Glute', anatomical: 'Gluteus medius' },
  
  // Bones
  ribcage: { common: 'Rib Cage', anatomical: 'Thoracic cage' },
  sternum: { common: 'Breastbone', anatomical: 'Sternum' },
  thoracic_vertebrae: { common: 'Upper Back Bones', anatomical: 'Thoracic vertebrae' },
  lumbar_vertebrae: { common: 'Lower Back Bones', anatomical: 'Lumbar vertebrae' },
  pelvis: { common: 'Hip Bones', anatomical: 'Pelvic girdle' },
  sacrum: { common: 'Base of Spine', anatomical: 'Sacrum' },
  coccyx: { common: 'Tailbone', anatomical: 'Coccyx' },
  ilium: { common: 'Hip Wing', anatomical: 'Ilium' },
  ischium: { common: 'Sit Bone', anatomical: 'Ischium' },
  pubis: { common: 'Pubic Bone', anatomical: 'Pubis' },
};

interface ExportedStructure {
  meshId: string;
  originalName: string;
  type: string;
  layer: number;
  regions: string[];
  center: [number, number, number];
}

interface ExportedMetadata {
  version: string;
  source: string;
  region: string;
  structures: Record<string, ExportedStructure>;
}

function toTitleCase(str: string): string {
  return str
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

function getNames(meshId: string, originalName: string): { common: string; anatomical: string } {
  // Check our mappings first
  if (NAME_MAPPINGS[meshId]) {
    return NAME_MAPPINGS[meshId];
  }
  
  // Generate from mesh ID
  const titleCased = toTitleCase(meshId);
  return {
    common: titleCased,
    anatomical: titleCased,
  };
}

function getColors(type: string): { default: string; highlight: string } {
  return TYPE_COLORS[type] || TYPE_COLORS.muscle;
}

function generateTypeScript(metadata: ExportedMetadata): string {
  const structures = Object.values(metadata.structures);
  
  let output = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
 * 
 * Generated from Z-Anatomy export metadata.
 * Source: ${metadata.source}
 * Region: ${metadata.region}
 * Structures: ${structures.length}
 * 
 * To regenerate, run: npx ts-node scripts/generate_data.ts
 */

import type { AnatomicalStructure, RenderConfig } from '@/types';

// ============================================================
// GENERATED STRUCTURES
// ============================================================

export const generatedStructures: AnatomicalStructure[] = [
`;

  for (const struct of structures) {
    const names = getNames(struct.meshId, struct.originalName);
    const systems = struct.type === 'bone' ? "['skeletal']" : 
                    struct.type === 'organ' ? "['digestive']" :  // Simplified
                    "['muscular']";
    
    output += `  {
    id: '${struct.meshId}',
    meshId: '${struct.meshId}',
    commonName: '${names.common}',
    anatomicalName: '${names.anatomical}',
    type: '${struct.type}',
    layer: ${struct.layer},
    systems: ${systems},
    regions: ${JSON.stringify(struct.regions)},
  },
`;
  }

  output += `];

// ============================================================
// GENERATED RENDER CONFIGS
// ============================================================

export const generatedRenderConfigs: Record<string, RenderConfig> = {
`;

  for (const struct of structures) {
    const colors = getColors(struct.type);
    const opacity = struct.type === 'bone' ? 1 : 
                    struct.layer === 1 ? 0.75 :
                    struct.layer === 2 ? 0.85 : 0.9;
    const visibleAt = struct.layer <= 1 ? 0.5 : struct.layer === 2 ? 0.3 : 0;
    
    output += `  '${struct.meshId}': {
    structureId: '${struct.meshId}',
    defaultColor: '${colors.default}',
    highlightColor: '${colors.highlight}',
    opacity: ${opacity},
    visibleAtZoomLevel: ${visibleAt},
    labelAnchorOffset: [${struct.center.map(c => (c * 0.5).toFixed(2)).join(', ')}],
  },
`;
  }

  output += `};

// ============================================================
// HELPER: Merge with manually curated data
// ============================================================

/**
 * Use this to merge generated data with your hand-curated content.
 * Generated data provides the structure, you add the descriptions.
 */
export function mergeWithContent<T extends { structureId: string }>(
  generatedConfigs: Record<string, T>,
  manualContent: Record<string, Partial<T>>
): Record<string, T> {
  const merged: Record<string, T> = { ...generatedConfigs };
  
  for (const [id, content] of Object.entries(manualContent)) {
    if (merged[id]) {
      merged[id] = { ...merged[id], ...content };
    }
  }
  
  return merged;
}
`;

  return output;
}

async function main() {
  console.log('\\nüì¶ Converting Z-Anatomy metadata to app format...\\n');
  
  // Check if metadata exists
  if (!fs.existsSync(METADATA_PATH)) {
    console.error(`‚ùå Metadata file not found: ${METADATA_PATH}`);
    console.error('\\nRun the Blender export script first to generate the metadata.');
    process.exit(1);
  }
  
  // Read metadata
  const metadataRaw = fs.readFileSync(METADATA_PATH, 'utf-8');
  const metadata: ExportedMetadata = JSON.parse(metadataRaw);
  
  console.log(`üìÇ Source: ${metadata.source}`);
  console.log(`üéØ Region: ${metadata.region}`);
  console.log(`üìä Structures: ${Object.keys(metadata.structures).length}`);
  
  // Generate TypeScript
  const tsContent = generateTypeScript(metadata);
  
  // Write output
  fs.writeFileSync(OUTPUT_PATH, tsContent);
  console.log(`\\n‚úÖ Generated: ${OUTPUT_PATH}`);
  
  // Summary by type
  const byType: Record<string, number> = {};
  for (const struct of Object.values(metadata.structures)) {
    byType[struct.type] = (byType[struct.type] || 0) + 1;
  }
  
  console.log('\\nüìã Summary by type:');
  for (const [type, count] of Object.entries(byType).sort((a, b) => b[1] - a[1])) {
    console.log(`   ${type}: ${count}`);
  }
  
  console.log('\\nüéâ Done! Update your data imports to use the generated file.\\n');
}

main().catch(console.error);
